
// impl PartialEq for PredicateExpression {
//     // True iff self and other are equivalent boolean formulas
//     fn eq(&self, other: &Self) -> bool {
//         // let new_invariant = AbstractProperty::lub(self, other);

//         let (other, _) = other.uniquely_rename(|s| self.named_variables.contains_key(s));
//         // let invariant = Predicate::And(Box::new(self.invariant.clone()), Box::new(other.invariant.clone()));
//         let mut cfg = Config::new();
//         cfg.set_timeout_msec(1000);
//         let context = Context::new(&cfg);
//         let lhs_invariant = self.invariant.into_sat(&context);
//         match lhs_invariant {
//             Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//             Z3Repr::Bool(il) => {
//                 let rhs_invariant = other.invariant.into_sat(&context);
//                 match rhs_invariant {
//                     Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                     Z3Repr::Bool(ir) => {
//                         let to_check = Predicate::Not(Box::new(Predicate::Equal(Box::new(other.named_variables.get(&self.representative).unwrap_or(self.named_variables.get(&self.representative).unwrap_or(&Predicate::IntegerLiteral(0))).clone()),
//                                                                                 Box::new(other.named_variables.get(&other.representative).unwrap_or(&Predicate::IntegerLiteral(0)).clone()))));
//                         let to_check = to_check.into_sat(&context);
//                         match to_check {
//                             Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                             Z3Repr::Bool(tc) => {
//                                 let solver = Solver::new(&context);
//                                 solver.assert(&ir);
//                                 solver.assert(&il);
//                                 solver.assert(&tc);
//                                 match solver.check() {
//                                     z3::SatResult::Unsat => true,
//                                     z3::SatResult::Unknown => panic!("Sat solver timeout"),
//                                     z3::SatResult::Sat => false,
//                                 }
//                             }
//                         }
//                     },
//                 }
//             },
//         }
//     }
// }

// impl PartialOrd for PredicateExpression {
//     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
//         // println!("invariants, {:?} {:?}", self.invariant, other.invariant);
//         let lt;
//         {
//             let (other, _) = other.uniquely_rename(|s| self.named_variables.contains_key(s));
//             // let invariant = Predicate::And(Box::new(self.invariant.clone()), Box::new(other.invariant.clone()));
//             let mut cfg = Config::new();
//             cfg.set_timeout_msec(1000);
//             let context = Context::new(&cfg);
//             let lhs_invariant = self.invariant.into_sat(&context);
//             match lhs_invariant {
//                 Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                 Z3Repr::Bool(il) => {
//                     let rhs_invariant = other.invariant.into_sat(&context);
//                     match rhs_invariant {
//                         Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                         Z3Repr::Bool(ir) => {
//                             let to_check = Predicate::Not(Box::new(Predicate::LessThan(Box::new(other.named_variables.get(&self.representative).unwrap_or(self.named_variables.get(&self.representative).unwrap_or(&Predicate::IntegerLiteral(0))).clone()),
//                                                                                     Box::new(other.named_variables.get(&other.representative).unwrap_or(&Predicate::IntegerLiteral(0)).clone()))));
//                             let to_check = to_check.into_sat(&context);
//                             match to_check {
//                                 Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                                 Z3Repr::Bool(tc) => {
//                                     let solver = Solver::new(&context);
//                                     solver.assert(&ir);
//                                     solver.assert(&il);
//                                     solver.assert(&tc);
//                                     match solver.check() {
//                                         z3::SatResult::Unsat => {lt = true;},
//                                         z3::SatResult::Unknown => panic!("Sat solver timeout"),
//                                         z3::SatResult::Sat => {lt = false;},
//                                     }
//                                 }
//                             }
//                         },
//                     }
//                 },
//             }
//         }

//         let eq = self.eq(other);

//         // println!("checking gt");
//         let gt;
//         {
//             let (other, _) = other.uniquely_rename(|s| self.named_variables.contains_key(s));
//             // let invariant = Predicate::And(Box::new(self.invariant.clone()), Box::new(other.invariant.clone()));
//             let mut cfg = Config::new();
//             cfg.set_timeout_msec(1000);
//             let context = Context::new(&cfg);
//             // println!("lhs looks like: {:?}", self);
//             let lhs_invariant = self.invariant.into_sat(&context);
//             match lhs_invariant {
//                 Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                 Z3Repr::Bool(il) => {
//                     let rhs_invariant = other.invariant.into_sat(&context);
//                     match rhs_invariant {
//                         Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                         Z3Repr::Bool(ir) => {
//                             let to_check = Predicate::Not(Box::new(Predicate::GreaterThan(Box::new(other.named_variables.get(&self.representative).unwrap_or(self.named_variables.get(&self.representative).unwrap_or(&Predicate::IntegerLiteral(0))).clone()),
//                                                                                           Box::new(other.named_variables.get(&other.representative).unwrap_or(&Predicate::IntegerLiteral(0)).clone()))));
//                             let to_check = to_check.into_sat(&context);
//                             match to_check {
//                                 Z3Repr::Int(_) => panic!("Invariants must be Boolean Expressions"),
//                                 Z3Repr::Bool(tc) => {
//                                     let solver = Solver::new(&context);
//                                     solver.assert(&il);
//                                     solver.assert(&ir);
//                                     solver.assert(&tc);
//                                     // println!("solver state: {:?}", solver);
//                                     match solver.check() {
//                                         z3::SatResult::Unsat => {gt = true;},
//                                         z3::SatResult::Unknown => panic!("Sat solver timeout"),
//                                         z3::SatResult::Sat => {gt = false;},
//                                     }
//                                 }
//                             }
//                         },
//                     }
//                 },
//             }
//         }
//         // This looks suspect from an overapproximation standpoint
//         // println!("returning {:?} {:?} {:?}", lt, eq, gt);
//         match (lt, eq, gt) {
//             (true, false, false) => {Some(Ordering::Less) },
//             (false, true, false) => {Some(Ordering::Equal)},
//             (false, false, true) => {Some(Ordering::Greater)},
//             _ => {(lt, eq, gt); None}
//         }
//     }
// }
